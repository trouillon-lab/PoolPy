[{"name": "app.py", "content": "from shiny import App, ui, reactive, render\nimport pandas as pd\nimport os\nimport pickle\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the UI\napp_ui = ui.page_fluid(\n    #Centered Title\n    ui.h2(\"Pooling\", style=\"text-align: center;\"),\n    \n    # Row with two input fields side by side (one on the left, one on the right)\n    ui.row(\n        ui.column(3),\n        ui.column(\n            5,\n            ui.input_numeric(\"n_samp\", \"Number of Samples:\", value=20)\n        ),\n        ui.column(\n            2,\n            ui.input_numeric(\"differentiate\", \"Max number of positives:\", value=1)\n        )\n    ),\n    \n    # Submit button centered below inputs\n    ui.row(\n        ui.column(\n            12,\n            ui.input_action_button(\"submit\", \"Enter\", style=\"display: block; margin-left: auto; margin-right: auto;\")\n        )\n    ),\n    \n    # Text output for displaying last submitted values, centered below inputs\n    ui.hr(),\n    ui.div(\n        ui.h4(\"Last submitted values:\"),\n        ui.output_text_verbatim(\"last_val\"),\n        style=\"text-align: center;\"\n    ),\n\n    ui.hr(),\n    ui.div(\n        ui.h4(\"Database reply\"),\n        ui.output_text_verbatim(\"database_r\"),  \n        #ui.div(\n        #ui.download_button(\"download_pickle\", \"Download complete pickled file\"),\n        #style=\"text-align: center; margin-top: 60px;\"\n        #),\n        style=\"text-align: center;\"\n    ),\n\n    ui.hr(),\n    ui.div(\n        ui.h4(\"Summary pooling strategy table\", style=\"text-align: center;\"),\n        # Wrap the table in a div and apply margin-left and margin-right for centering\n        ui.div(\n            ui.output_data_frame(\"summary_t\"),\n            style=\"display: flex; justify-content: center;\"  # Flexbox centering\n        ),\n        ui.div(\n        ui.download_button(\"download_summary\", \"Download summary\"),\n        style=\"text-align: center; margin-top: 60px;\"\n        )\n    ),\n\n    ui.hr(),\n    ui.div(\n        ui.h4(\"Command to run code locally\"),\n        ui.output_text_verbatim(\"commands\"),  \n        \n        style=\"text-align: center;\"\n    ),\n\n\n    ui.hr(),\n    ui.div(\n        ui.h4(\"Downloadable tables\"),\n        #ui.output_text_verbatim(\"table_text\"),  \n        ui.download_button(\"download_table_matrix\", \"Matrix pooling\"),\n        ui.download_button(\"download_table_2d\", \"2-dimensional pooling\"),\n        ui.download_button(\"download_table_3d\", \"3-dimensional pooling\"),\n        ui.download_button(\"download_table_4d\", \"4-dimensional pooling\"),\n        ui.download_button(\"download_table_random\", \"Random pooling\"),\n        ui.download_button(\"download_table_STD\", \"STD pooling\"),\n        ui.download_button(\"download_table_CT\", \"Chinese reminder pooling\"),\n        ui.download_button(\"download_table_binary\", \"Binary pooling\"),\n        style=\"text-align: center;\",\n    ),\n\n\n    # Conditionally display the summary table if extra_computation is False\n    ui.hr(),\n    ui.panel_conditional(\n        \"output.extra_computation === false\",  # JavaScript condition to check if extra_computation is False\n        ui.h4(\"Histogram Plot\"),\n        ui.output_plot(\"histogram_plot\")  # Output container for the plot\n    ),\n    \n    # Section for downloadable tables with dynamic names\n    ui.hr(),\n    ui.panel_conditional(\n        \"output.extra_computation === false\",  # JavaScript condition to check if extra_computation is False\n        ui.h4(\"Downloadable Tables\"),\n        ui.div(\n            {\"id\": \"download-section\"},\n            ui.output_ui(\"download_buttons\")  # Placeholder for dynamically generated download buttons with names\n        )\n    ),\n    \n    # JavaScript for copying text to clipboard\n    ui.tags.script(\"\"\"\n        function copyCommand(command) {\n            navigator.clipboard.writeText(command).then(function() {\n                alert('Copied to clipboard: ' + command);\n            }).catch(function(error) {\n                console.error('Failed to copy text: ', error);\n            });\n        }\n    \"\"\"),\n\n    # JavaScript to trigger button click on Enter key press for both input fields\n    ui.tags.script('''\n        document.getElementById('n_samp').addEventListener('keydown', function(event) {\n            if (event.key === 'Enter') {\n                event.preventDefault();  // Prevent default form submission\n                document.getElementById('submit').click();  // Trigger button click\n            }\n        });\n\n        document.getElementById('differentiate').addEventListener('keydown', function(event) {\n            if (event.key === 'Enter') {\n                event.preventDefault();  // Prevent default form submission\n                document.getElementById('submit').click();  // Trigger button click\n            }\n        });\n    ''')\n)\nWA_DIRECTORY='precomputed'\n#SCRAMBLER_DIRECTORY='.\\output'\nMAX_DIFFERENTIATE=4\n\ndef find_n_folder(n_samp, wa_directory):\n    folders = [f for f in os.listdir(wa_directory) if os.path.isdir(os.path.join(wa_directory, f)) and f.startswith('N_')]\n    x_values = [int(f.split('_')[1]) for f in folders]\n    if n_samp in x_values:\n        return f'N_{n_samp}'\n    greater_x = [x for x in x_values if x > n_samp]\n    if greater_x:\n        smallest_x = min(greater_x)\n        return f'N_{smallest_x}'\n    return None\n\ndef find_closest_diff_folder(n_folder_path, differentiate):\n    folders = [f for f in os.listdir(n_folder_path) if os.path.isdir(os.path.join(n_folder_path, f)) and f.startswith('diff_')]\n    y_values = [int(f.split('_')[1]) for f in folders]\n    if differentiate in y_values:\n        return f'diff_{differentiate}'\n    if y_values:\n        closest_y = min(y_values, key=lambda y: abs(y - differentiate))\n        return f'diff_{closest_y}'\n    return None\n\nimport os\nimport pandas as pd\n\ndef load_wa_matrices(folder_path):\n    DFFS = {}\n    # List all files in the folder\n    files = [f for f in os.listdir(folder_path) if os.path.isfile(os.path.join(folder_path, f))]\n    \n    for file in files:\n        # Check if file matches the WA_Method_N_x_diff_y pattern\n        if file.startswith('WA_') and file.endswith('.csv'):\n            # Example filename: WA_Method_N_10_diff_2.xlsx\n            parts = file.split('_')\n            # Extract method name (between WA_ and N_x)\n            try:\n                n_index = next(i for i, part in enumerate(parts) if part.startswith('N'))\n                method_name = '_'.join(parts[1:n_index])\n                # Load the Excel file as a DataFrame\n                file_path = os.path.join(folder_path, file)\n                matrix_df = pd.read_csv(file_path, header=None)\n                # Rename columns and index\n                matrix_df.columns = ['Pool ' + str(i) for i in range(matrix_df.shape[1])]\n                matrix_df.index = ['Sample ' + str(i) for i in range(matrix_df.shape[0])]\n                # Store in dictionary with method name as key\n                DFFS[method_name] = matrix_df\n            except StopIteration:\n                # If no N_x part found, skip this file\n                continue\n    return DFFS\n\n\n\n\n# Define the server logic\ndef server(input, output, session):\n\n    output.last_values = reactive.Value(\"\")\n    output.database_reply = reactive.Value(\"\")\n    output.extra_computation = reactive.Value(0)\n    output.personalized_command = reactive.Value(\"\")\n    output.dataframes = reactive.Value(0)\n    output.full_pickle = reactive.Value(0)\n\n\n    ls_met=['Pooling strategy', 'mean_experiments', 'max_compounds_per_well', 'n_wells', 'percentage_check', 'mean_extra_exp']\n    output.summary_table = reactive.Value(pd.DataFrame(columns=ls_met))\n\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        # Get user inputs\n        n_samp = input.n_samp()\n        differentiate = input.differentiate()\n        #print(n_samp)\n\n        last_values_text = f\"Max number of samples: {n_samp}, Max positives: {differentiate}\"\n        \n        # Set output to display last submitted values\n        output.last_values.set(last_values_text)\n\n        if differentiate > n_samp:\n            output_text=f'Maximum number of positives ({differentiate}) must always be smaller than the total number of samples ({n_samp})'\n            output.database_reply.set(output_text)\n            output.extra_computation.set(1)\n\n        elif differentiate > MAX_DIFFERENTIATE:\n            output_text=f'Maximum number of positives ({differentiate}) too high. The precomputed maximum is 4. To locally run the code for your specific setting follow the section below'\n            output.database_reply.set(output_text)\n            output.extra_computation.set(1)\n\n        else:\n            n_folder = find_n_folder(n_samp, WA_DIRECTORY)\n            if n_folder:\n                n_folder_path = os.path.join(WA_DIRECTORY, n_folder)\n                diff_folder = find_closest_diff_folder(n_folder_path, differentiate)\n                if diff_folder:\n                    diff_folder_path = os.path.join(n_folder_path, diff_folder)\n                    excel_filename = f'Metrics_{n_folder}_diff_{diff_folder.split(\"_\")[1]}.csv'\n                    excel_path = os.path.join(diff_folder_path, excel_filename)\n                    output_text=f'There is a precomputed strategy for {n_samp} samples with up to {differentiate} positives'\n                    output.database_reply.set(output_text)\n                    #print(output_text)\n                    if os.path.isfile(excel_path):\n                        metrics_data = pd.read_csv(excel_path)\n\n                        # Use metrics_data as needed\n                    else:\n                        # Handle missing metrics file\n                        pass\n                else:\n                    # Handle missing diff_y folders\n                    pass\n            else:\n                # Handle missing N_x folders\n                pass\n\n            '''\n            full_dir='Final_precomputed_file.pk'\n            with open(full_dir, 'rb') as handle:\n                f1=pickle.load(handle)\n            f2=f1['Differentiate '+str(differentiate)]\n            a2=np.array(list(f2))\n            md=np.max(a2)\n            if n_samp>md:\n                output_text=f'Maximum number of samples ({n_samp}) too high for the chosen number of positives \\n Below are displayed the information for {md} samples and up to {differentiate} positives. \\n You can run the code following the commands below for your specific case.'\n                output.database_reply.set(output_text)\n                output.extra_computation.set(0)\n\n            elif np.sum(a2==n_samp)==0:\n                md=np.min(a2[a2>n_samp])\n                output_text=f'There is no precomputed strategy for {n_samp} samples. \\n The closest precomputed strategy is for {md} samples with up to {differentiate} positives'\n                output.database_reply.set(output_text)\n                output.extra_computation.set(0)\n\n            else:\n                md=n_samp\n                output_text=f'There is a precomputed strategy for {n_samp} samples with up to {differentiate} positives'\n                output.database_reply.set(output_text)\n                output.extra_computation.set(0)I go\n\n            \n            \n            CR=f2[md]\n            output.full_pickle.set(CR)\n            '''\n\n            #DFT=CR[0]\n            #DFT.insert(loc=0, column='Pooling strategy', value=DFT.index)\n            metrics_data.drop(metrics_data.columns[0], axis=1, inplace=True)\n            #ls_met_nice=['Pooling design', 'Mean total experiments', 'Max samples per pool', 'N pools', '\\% multiple rounds', 'Mean extra experiments']\n            dict_ren={'N wells':'N pools'}#{i:j for i,j in zip(metrics_data.columns,ls_met_nice)}\n            metrics_data.rename(columns=dict_ren, inplace=True)\n            #metrics_data.rename(index={'Chinese trick':'Chinese reminder'}, inplace=True)\n            output.summary_table.set(metrics_data)\n\n            #TBLS=CR[1]\n            DFFS={}\n            table_path=os.path.join(diff_folder_path,'WAs')\n            TBLS=load_wa_matrices(table_path)\n            #print(table_path)\n            for idx in TBLS.keys():\n                b1=TBLS[idx]\n                tmp1=pd.DataFrame(b1, columns=['Pool '+ str(i) for i in range(b1.shape[1])], index=['Sample '+ str(i) for i in range(b1.shape[0])])\n                DFFS.update({idx:tmp1})\n\n            output.dataframes.set(DFFS)\n            #print(DFFS.keys())\n\n            \n            \n            \n        # Prepare the correct command for pool_N.py based on its arguments\n        command_p = f\"python pool_N.py --n_samp {n_samp} --differentiate {differentiate} --method all --path your/path\"\n        output.personalized_command.set(command_p)\n\n            #md=np.max(np.array(list(f2)))\n\n\n\n        #md=np.max(np.array(list(f2)))\n\n\n\n        if False:\n\n            if differentiate > md:\n                output.database_reply.set('output_text')\n\n            md=np.max(np.array(list(f1)))\n            if differentiate > np.max(np.array(list(f1))):\n                output_text=f'Number of samples too high for chosen max number of positives ({differentiate}) <br> max number of samples pre-computed for pooling {md}. <br>'\n                output.database_reply.set(output_text)\n                extra_computation=True\n\n            full_dir='Final_precomputed_file.pk'\n            with open(full_dir, 'rb') as handle:\n                f1=pickle.load(handle)\n            \n            md=np.max(np.array(list(f1)))\n            if differentiate > np.max(np.array(list(f1))):\n                output_text=f'Differentiate too high, max diffrentiate pre-computed {md}. <br>'\n                extra_computation=True\n\n\n            else:\n                nm='Differentiate '+ differentiate\n                f2=f1[nm]\n                l2=list(f2)\n                a2=np.array(l2)\n                if n_samp in l2:\n                    n_samp_new=n_samp.copy()\n\n                elif n_samp<np.max(a2):\n                    n_samp_new=a2[a2>n_samp][0] \n\n                else:\n                    extra_computation=True\n\n                if n_samp_new in l2:\n                    f3=f2[n_samp]\n                    summary=f3[0]\n                    table_names=summary.index\n                    tables=[i for i in f3.values()]\n\n\n\n            download_buttons_html = \"\".join([\n                f\"<div><strong>{table_names[i]}</strong>: \"\n                f\"<button id='download_table_{i}' onclick='Shiny.download(\\\"download_table_{i}\\\")'>Download {table_names[i]}</button></div><br>\"\n                for i in range(len(tables))\n            ])\n\n            output.download_buttons.set(ui.HTML(download_buttons_html))\n\n\n\n\n            # Prepare terminal commands based on extra_computation results and user inputs\n            commands = [\n                f\"echo 'git clone https://github.com/trouillon-lab/pooling.git'\",  \n                f\"echo 'conda env create -n pooling --file=environments.yml'\",\n                f\"echo 'conda activate pooling'\",\n                f\"echo 'python pre-computation.py --start {n_samp} --stop {n_samp+1} --step 1 --differentiate {differentiate} --rand_guesses 10'\" \n                f\"process_data --samples {n_samp} --diff {differentiate}\"\n            ]\n\n            # Generate HTML content for displaying commands with copy buttons\n            command_html = \"\".join([\n                f\"<div><code>{command}</code> \"\n                f\"<button onclick=\\\"copyCommand('{command}')\\\">Copy Command {i+1}</button></div><br>\"\n                for i, command in enumerate(commands)\n            ])\n\n            # Set the dynamically generated HTML content in the output UI\n            output.commands_output.set(ui.HTML(command_html))\n\n\n            # Set extra_computation flag to control conditional panel for plot\n            output.extra_computation.set(extra_computation)\n\n\n    @output\n    @render.plot\n    def histogram_plot():\n        # Check if extra_computation is False before generating the plot\n        #if not output.extra_computation.get():\n        # Generate random data for histogram\n        np.random.seed(19680801)\n        data = 100 + 15 * np.random.randn(437)\n        \n        # Create a histogram with a fixed number of bins (or customize based on inputs)\n        fig, ax = plt.subplots()\n        ax.hist(data, bins=30, density=True)  # Fixed bins for simplicity or customize as needed\n        ax.set_title(\"Histogram of Random Data\")\n        ax.set_xlabel(\"Value\")\n        ax.set_ylabel(\"Density\")\n        \n        return fig\n\n    @output\n    @render.text\n    def last_val():\n        return  output.last_values.get()\n    \n    @output\n    @render.text\n    def database_r():\n        return  output.database_reply.get()\n    \n    @output\n    @render.text\n    def commands():\n        return  output.personalized_command.get()\n    \n    @output\n    @render.data_frame\n    def summary_t():      \n        return output.summary_table.get()\n    \n    @output\n    @render.download(filename=lambda: \"summary.csv\")\n    async def download_summary():\n        # Yield the content of the CSV file\n        yield output.summary_table.get().to_csv(index=False)\n    \n    @output\n    @render.download(filename=lambda: \"matrix_pooling.csv\")\n    async def download_table_matrix():\n        # Yield the content of the CSV file\n        DFFS=output.dataframes.get()\n        yield DFFS['Matrix'].to_csv(index=True)\n    \n    @output\n    @render.download(filename=lambda: \"2D_pooling.csv\")\n    async def download_table_2d():\n        # Yield the content of the CSV file\n        DFFS=output.dataframes.get()\n        #idt=[i for i in list(DFFS) if i.startswith('multidim')]\n        yield DFFS['multidim-2'].to_csv(index=True)\n\n    @output\n    @render.download(filename=lambda: \"3D_pooling.csv\")\n    async def download_table_3d():\n        # Yield the content of the CSV file\n        DFFS=output.dataframes.get()\n        #idt=[i for i in list(DFFS) if i.startswith('multidim')]\n        yield DFFS['multidim-3'].to_csv(index=True)\n\n    @output\n    @render.download(filename=lambda: \"4D_pooling.csv\")\n    async def download_table_4d():\n        # Yield the content of the CSV file\n        DFFS=output.dataframes.get()\n        #idt=[i for i in list(DFFS) if i.startswith('multidim')]\n        yield DFFS['multidim-4'].to_csv(index=True)\n\n    @output\n    @render.download(filename=lambda: \"random_pooling.csv\")\n    async def download_table_random():\n        # Yield the content of the CSV file\n        DFFS=output.dataframes.get()\n        yield DFFS['Random'].to_csv(index=True)\n    \n    @output\n    @render.download(filename=lambda: \"STD_pooling.csv\")\n    async def download_table_STD():\n        # Yield the content of the CSV file\n        DFFS=output.dataframes.get()\n        yield DFFS['STD'].to_csv(index=True)\n\n    @output\n    @render.download(filename=lambda: \"Chinese_reminder_pooling.csv\")\n    async def download_table_CT():\n        # Yield the content of the CSV file\n        DFFS=output.dataframes.get()\n        yield DFFS['Chinese trick'].to_csv(index=True)\n\n    @output\n    @render.download(filename=lambda: \"binary_pooling.csv\")\n    async def download_table_binary():\n        # Yield the content of the CSV file\n        DFFS=output.dataframes.get()\n        try:\n            yield DFFS['Binary'].to_csv(index=True)\n        except:\n            yield pd.DataFrame().to_csv(index=True)\n'''\n    @output\n    @render.download(filename=lambda: \"full_pooling.pk\")\n    async def download_pickle():\n        with open('temp.pkl', 'wb') as f:\n            pickle.dump(output.full_pickle, f)\n            f.seek(0)  # Move back to start of file before yielding content\n        \n        # Read back and yield content for download\n        with open('temp.pkl', 'rb') as f:\n            yield f.read()\n\n\n    #@output.plot(\"plot_placeholder\")\n    #def plot():\n        # Placeholder for future plot implementation\n    #    pass\n'''\n\n# Create the app object\napp = App(app_ui, server)", "type": "text"}, {"name": "pooling.py", "content": "from shiny import App, ui, reactive, render\nimport pandas as pd\nimport os\nimport pickle\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the UI\napp_ui = ui.page_fluid(\n    #Centered Title\n    ui.h2(\"Pooling\", style=\"text-align: center;\"),\n    \n    # Row with two input fields side by side (one on the left, one on the right)\n    ui.row(\n        ui.column(3),\n        ui.column(\n            5,\n            ui.input_numeric(\"n_samp\", \"Number of Samples:\", value=20)\n        ),\n        ui.column(\n            2,\n            ui.input_numeric(\"differentiate\", \"Max number of positives:\", value=1)\n        )\n    ),\n    \n    # Submit button centered below inputs\n    ui.row(\n        ui.column(\n            12,\n            ui.input_action_button(\"submit\", \"Enter\", style=\"display: block; margin-left: auto; margin-right: auto;\")\n        )\n    ),\n    \n    # Text output for displaying last submitted values, centered below inputs\n    ui.hr(),\n    ui.div(\n        ui.h4(\"Last submitted values:\"),\n        ui.output_text_verbatim(\"last_val\"),\n        style=\"text-align: center;\"\n    ),\n\n    ui.hr(),\n    ui.div(\n        ui.h4(\"Database reply\"),\n        ui.output_text_verbatim(\"database_r\"),  \n        #ui.div(\n        #ui.download_button(\"download_pickle\", \"Download complete pickled file\"),\n        #style=\"text-align: center; margin-top: 60px;\"\n        #),\n        style=\"text-align: center;\"\n    ),\n\n    ui.hr(),\n    ui.div(\n        ui.h4(\"Summary pooling strategy table\", style=\"text-align: center;\"),\n        # Wrap the table in a div and apply margin-left and margin-right for centering\n        ui.div(\n            ui.output_data_frame(\"summary_t\"),\n            style=\"display: flex; justify-content: center;\"  # Flexbox centering\n        ),\n        ui.div(\n        ui.download_button(\"download_summary\", \"Download summary\"),\n        style=\"text-align: center; margin-top: 60px;\"\n        )\n    ),\n\n    ui.hr(),\n    ui.div(\n        ui.h4(\"Command to run code locally\"),\n        ui.output_text_verbatim(\"commands\"),  \n        \n        style=\"text-align: center;\"\n    ),\n\n\n    ui.hr(),\n    ui.div(\n        ui.h4(\"Downloadable tables\"),\n        #ui.output_text_verbatim(\"table_text\"),  \n        ui.download_button(\"download_table_matrix\", \"Matrix pooling\"),\n        ui.download_button(\"download_table_2d\", \"2-dimensional pooling\"),\n        ui.download_button(\"download_table_3d\", \"3-dimensional pooling\"),\n        ui.download_button(\"download_table_4d\", \"4-dimensional pooling\"),\n        ui.download_button(\"download_table_random\", \"Random pooling\"),\n        ui.download_button(\"download_table_STD\", \"STD pooling\"),\n        ui.download_button(\"download_table_CT\", \"Chinese reminder pooling\"),\n        ui.download_button(\"download_table_binary\", \"Binary pooling\"),\n        style=\"text-align: center;\",\n    ),\n\n\n    # Conditionally display the summary table if extra_computation is False\n    ui.hr(),\n    ui.panel_conditional(\n        \"output.extra_computation === false\",  # JavaScript condition to check if extra_computation is False\n        ui.h4(\"Histogram Plot\"),\n        ui.output_plot(\"histogram_plot\")  # Output container for the plot\n    ),\n    \n    # Section for downloadable tables with dynamic names\n    ui.hr(),\n    ui.panel_conditional(\n        \"output.extra_computation === false\",  # JavaScript condition to check if extra_computation is False\n        ui.h4(\"Downloadable Tables\"),\n        ui.div(\n            {\"id\": \"download-section\"},\n            ui.output_ui(\"download_buttons\")  # Placeholder for dynamically generated download buttons with names\n        )\n    ),\n    \n    # JavaScript for copying text to clipboard\n    ui.tags.script(\"\"\"\n        function copyCommand(command) {\n            navigator.clipboard.writeText(command).then(function() {\n                alert('Copied to clipboard: ' + command);\n            }).catch(function(error) {\n                console.error('Failed to copy text: ', error);\n            });\n        }\n    \"\"\"),\n\n    # JavaScript to trigger button click on Enter key press for both input fields\n    ui.tags.script('''\n        document.getElementById('n_samp').addEventListener('keydown', function(event) {\n            if (event.key === 'Enter') {\n                event.preventDefault();  // Prevent default form submission\n                document.getElementById('submit').click();  // Trigger button click\n            }\n        });\n\n        document.getElementById('differentiate').addEventListener('keydown', function(event) {\n            if (event.key === 'Enter') {\n                event.preventDefault();  // Prevent default form submission\n                document.getElementById('submit').click();  // Trigger button click\n            }\n        });\n    ''')\n)\nWA_DIRECTORY='D:\\precomputed'\nSCRAMBLER_DIRECTORY='D:\\output'\nMAX_DIFFERENTIATE=4\n\ndef find_n_folder(n_samp, wa_directory):\n    folders = [f for f in os.listdir(wa_directory) if os.path.isdir(os.path.join(wa_directory, f)) and f.startswith('N_')]\n    x_values = [int(f.split('_')[1]) for f in folders]\n    if n_samp in x_values:\n        return f'N_{n_samp}'\n    greater_x = [x for x in x_values if x > n_samp]\n    if greater_x:\n        smallest_x = min(greater_x)\n        return f'N_{smallest_x}'\n    return None\n\ndef find_closest_diff_folder(n_folder_path, differentiate):\n    folders = [f for f in os.listdir(n_folder_path) if os.path.isdir(os.path.join(n_folder_path, f)) and f.startswith('diff_')]\n    y_values = [int(f.split('_')[1]) for f in folders]\n    if differentiate in y_values:\n        return f'diff_{differentiate}'\n    if y_values:\n        closest_y = min(y_values, key=lambda y: abs(y - differentiate))\n        return f'diff_{closest_y}'\n    return None\n\nimport os\nimport pandas as pd\n\ndef load_wa_matrices(folder_path):\n    DFFS = {}\n    # List all files in the folder\n    files = [f for f in os.listdir(folder_path) if os.path.isfile(os.path.join(folder_path, f))]\n    \n    for file in files:\n        # Check if file matches the WA_Method_N_x_diff_y pattern\n        if file.startswith('WA_') and file.endswith('.csv'):\n            # Example filename: WA_Method_N_10_diff_2.xlsx\n            parts = file.split('_')\n            # Extract method name (between WA_ and N_x)\n            try:\n                n_index = next(i for i, part in enumerate(parts) if part.startswith('N'))\n                method_name = '_'.join(parts[1:n_index])\n                # Load the Excel file as a DataFrame\n                file_path = os.path.join(folder_path, file)\n                matrix_df = pd.read_csv(file_path, header=None)\n                # Rename columns and index\n                matrix_df.columns = ['Pool ' + str(i) for i in range(matrix_df.shape[1])]\n                matrix_df.index = ['Sample ' + str(i) for i in range(matrix_df.shape[0])]\n                # Store in dictionary with method name as key\n                DFFS[method_name] = matrix_df\n            except StopIteration:\n                # If no N_x part found, skip this file\n                continue\n    return DFFS\n\n\n\n\n# Define the server logic\ndef server(input, output, session):\n\n    output.last_values = reactive.Value(\"\")\n    output.database_reply = reactive.Value(\"\")\n    output.extra_computation = reactive.Value(0)\n    output.personalized_command = reactive.Value(\"\")\n    output.dataframes = reactive.Value(0)\n    output.full_pickle = reactive.Value(0)\n\n\n    ls_met=['Pooling strategy', 'mean_experiments', 'max_compounds_per_well', 'n_wells', 'percentage_check', 'mean_extra_exp']\n    output.summary_table = reactive.Value(pd.DataFrame(columns=ls_met))\n\n\n    @reactive.Effect\n    @reactive.event(input.submit)\n    def _():\n        # Get user inputs\n        n_samp = input.n_samp()\n        differentiate = input.differentiate()\n        #print(n_samp)\n\n        last_values_text = f\"Max number of samples: {n_samp}, Max positives: {differentiate}\"\n        \n        # Set output to display last submitted values\n        output.last_values.set(last_values_text)\n\n        if differentiate > n_samp:\n            output_text=f'Maximum number of positives ({differentiate}) must always be smaller than the total number of samples ({n_samp})'\n            output.database_reply.set(output_text)\n            output.extra_computation.set(1)\n\n        elif differentiate > MAX_DIFFERENTIATE:\n            output_text=f'Maximum number of positives ({differentiate}) too high. The precomputed maximum is 4. To locally run the code for your specific setting follow the section below'\n            output.database_reply.set(output_text)\n            output.extra_computation.set(1)\n\n        else:\n            n_folder = find_n_folder(n_samp, WA_DIRECTORY)\n            if n_folder:\n                n_folder_path = os.path.join(WA_DIRECTORY, n_folder)\n                diff_folder = find_closest_diff_folder(n_folder_path, differentiate)\n                if diff_folder:\n                    diff_folder_path = os.path.join(n_folder_path, diff_folder)\n                    excel_filename = f'Metrics_{n_folder}_diff_{diff_folder.split(\"_\")[1]}.csv'\n                    excel_path = os.path.join(diff_folder_path, excel_filename)\n                    output_text=f'There is a precomputed strategy for {n_samp} samples with up to {differentiate} positives'\n                    output.database_reply.set(output_text)\n                    #print(output_text)\n                    if os.path.isfile(excel_path):\n                        metrics_data = pd.read_csv(excel_path)\n\n                        # Use metrics_data as needed\n                    else:\n                        # Handle missing metrics file\n                        pass\n                else:\n                    # Handle missing diff_y folders\n                    pass\n            else:\n                # Handle missing N_x folders\n                pass\n\n            '''\n            full_dir='Final_precomputed_file.pk'\n            with open(full_dir, 'rb') as handle:\n                f1=pickle.load(handle)\n            f2=f1['Differentiate '+str(differentiate)]\n            a2=np.array(list(f2))\n            md=np.max(a2)\n            if n_samp>md:\n                output_text=f'Maximum number of samples ({n_samp}) too high for the chosen number of positives \\n Below are displayed the information for {md} samples and up to {differentiate} positives. \\n You can run the code following the commands below for your specific case.'\n                output.database_reply.set(output_text)\n                output.extra_computation.set(0)\n\n            elif np.sum(a2==n_samp)==0:\n                md=np.min(a2[a2>n_samp])\n                output_text=f'There is no precomputed strategy for {n_samp} samples. \\n The closest precomputed strategy is for {md} samples with up to {differentiate} positives'\n                output.database_reply.set(output_text)\n                output.extra_computation.set(0)\n\n            else:\n                md=n_samp\n                output_text=f'There is a precomputed strategy for {n_samp} samples with up to {differentiate} positives'\n                output.database_reply.set(output_text)\n                output.extra_computation.set(0)I go\n\n            \n            \n            CR=f2[md]\n            output.full_pickle.set(CR)\n            '''\n\n            #DFT=CR[0]\n            #DFT.insert(loc=0, column='Pooling strategy', value=DFT.index)\n            metrics_data.drop(metrics_data.columns[0], axis=1, inplace=True)\n            #ls_met_nice=['Pooling design', 'Mean total experiments', 'Max samples per pool', 'N pools', '\\% multiple rounds', 'Mean extra experiments']\n            dict_ren={'N wells':'N pools'}#{i:j for i,j in zip(metrics_data.columns,ls_met_nice)}\n            metrics_data.rename(columns=dict_ren, inplace=True)\n            #metrics_data.rename(index={'Chinese trick':'Chinese reminder'}, inplace=True)\n            output.summary_table.set(metrics_data)\n\n            #TBLS=CR[1]\n            DFFS={}\n            table_path=os.path.join(diff_folder_path,'WAs')\n            TBLS=load_wa_matrices(table_path)\n            #print(table_path)\n            for idx in TBLS.keys():\n                b1=TBLS[idx]\n                tmp1=pd.DataFrame(b1, columns=['Pool '+ str(i) for i in range(b1.shape[1])], index=['Sample '+ str(i) for i in range(b1.shape[0])])\n                DFFS.update({idx:tmp1})\n\n            output.dataframes.set(DFFS)\n            #print(DFFS.keys())\n\n            \n            \n            \n        # Prepare the correct command for pool_N.py based on its arguments\n        command_p = f\"python pool_N.py --n_samp {n_samp} --differentiate {differentiate} --method all --path your/path\"\n        output.personalized_command.set(command_p)\n\n            #md=np.max(np.array(list(f2)))\n\n\n\n        #md=np.max(np.array(list(f2)))\n\n\n\n        if False:\n\n            if differentiate > md:\n                output.database_reply.set('output_text')\n\n            md=np.max(np.array(list(f1)))\n            if differentiate > np.max(np.array(list(f1))):\n                output_text=f'Number of samples too high for chosen max number of positives ({differentiate}) <br> max number of samples pre-computed for pooling {md}. <br>'\n                output.database_reply.set(output_text)\n                extra_computation=True\n\n            full_dir='Final_precomputed_file.pk'\n            with open(full_dir, 'rb') as handle:\n                f1=pickle.load(handle)\n            \n            md=np.max(np.array(list(f1)))\n            if differentiate > np.max(np.array(list(f1))):\n                output_text=f'Differentiate too high, max diffrentiate pre-computed {md}. <br>'\n                extra_computation=True\n\n\n            else:\n                nm='Differentiate '+ differentiate\n                f2=f1[nm]\n                l2=list(f2)\n                a2=np.array(l2)\n                if n_samp in l2:\n                    n_samp_new=n_samp.copy()\n\n                elif n_samp<np.max(a2):\n                    n_samp_new=a2[a2>n_samp][0] \n\n                else:\n                    extra_computation=True\n\n                if n_samp_new in l2:\n                    f3=f2[n_samp]\n                    summary=f3[0]\n                    table_names=summary.index\n                    tables=[i for i in f3.values()]\n\n\n\n            download_buttons_html = \"\".join([\n                f\"<div><strong>{table_names[i]}</strong>: \"\n                f\"<button id='download_table_{i}' onclick='Shiny.download(\\\"download_table_{i}\\\")'>Download {table_names[i]}</button></div><br>\"\n                for i in range(len(tables))\n            ])\n\n            output.download_buttons.set(ui.HTML(download_buttons_html))\n\n\n\n\n            # Prepare terminal commands based on extra_computation results and user inputs\n            commands = [\n                f\"echo 'git clone https://github.com/trouillon-lab/pooling.git'\",  \n                f\"echo 'conda env create -n pooling --file=environments.yml'\",\n                f\"echo 'conda activate pooling'\",\n                f\"echo 'python pre-computation.py --start {n_samp} --stop {n_samp+1} --step 1 --differentiate {differentiate} --rand_guesses 10'\" \n                f\"process_data --samples {n_samp} --diff {differentiate}\"\n            ]\n\n            # Generate HTML content for displaying commands with copy buttons\n            command_html = \"\".join([\n                f\"<div><code>{command}</code> \"\n                f\"<button onclick=\\\"copyCommand('{command}')\\\">Copy Command {i+1}</button></div><br>\"\n                for i, command in enumerate(commands)\n            ])\n\n            # Set the dynamically generated HTML content in the output UI\n            output.commands_output.set(ui.HTML(command_html))\n\n\n            # Set extra_computation flag to control conditional panel for plot\n            output.extra_computation.set(extra_computation)\n\n\n    @output\n    @render.plot\n    def histogram_plot():\n        # Check if extra_computation is False before generating the plot\n        #if not output.extra_computation.get():\n        # Generate random data for histogram\n        np.random.seed(19680801)\n        data = 100 + 15 * np.random.randn(437)\n        \n        # Create a histogram with a fixed number of bins (or customize based on inputs)\n        fig, ax = plt.subplots()\n        ax.hist(data, bins=30, density=True)  # Fixed bins for simplicity or customize as needed\n        ax.set_title(\"Histogram of Random Data\")\n        ax.set_xlabel(\"Value\")\n        ax.set_ylabel(\"Density\")\n        \n        return fig\n\n    @output\n    @render.text\n    def last_val():\n        return  output.last_values.get()\n    \n    @output\n    @render.text\n    def database_r():\n        return  output.database_reply.get()\n    \n    @output\n    @render.text\n    def commands():\n        return  output.personalized_command.get()\n    \n    @output\n    @render.data_frame\n    def summary_t():      \n        return output.summary_table.get()\n    \n    @output\n    @render.download(filename=lambda: \"summary.csv\")\n    async def download_summary():\n        # Yield the content of the CSV file\n        yield output.summary_table.get().to_csv(index=False)\n    \n    @output\n    @render.download(filename=lambda: \"matrix_pooling.csv\")\n    async def download_table_matrix():\n        # Yield the content of the CSV file\n        DFFS=output.dataframes.get()\n        yield DFFS['Matrix'].to_csv(index=True)\n    \n    @output\n    @render.download(filename=lambda: \"2D_pooling.csv\")\n    async def download_table_2d():\n        # Yield the content of the CSV file\n        DFFS=output.dataframes.get()\n        #idt=[i for i in list(DFFS) if i.startswith('multidim')]\n        yield DFFS['multidim-2'].to_csv(index=True)\n\n    @output\n    @render.download(filename=lambda: \"3D_pooling.csv\")\n    async def download_table_3d():\n        # Yield the content of the CSV file\n        DFFS=output.dataframes.get()\n        #idt=[i for i in list(DFFS) if i.startswith('multidim')]\n        yield DFFS['multidim-3'].to_csv(index=True)\n\n    @output\n    @render.download(filename=lambda: \"4D_pooling.csv\")\n    async def download_table_4d():\n        # Yield the content of the CSV file\n        DFFS=output.dataframes.get()\n        #idt=[i for i in list(DFFS) if i.startswith('multidim')]\n        yield DFFS['multidim-4'].to_csv(index=True)\n\n    @output\n    @render.download(filename=lambda: \"random_pooling.csv\")\n    async def download_table_random():\n        # Yield the content of the CSV file\n        DFFS=output.dataframes.get()\n        yield DFFS['Random'].to_csv(index=True)\n    \n    @output\n    @render.download(filename=lambda: \"STD_pooling.csv\")\n    async def download_table_STD():\n        # Yield the content of the CSV file\n        DFFS=output.dataframes.get()\n        yield DFFS['STD'].to_csv(index=True)\n\n    @output\n    @render.download(filename=lambda: \"Chinese_reminder_pooling.csv\")\n    async def download_table_CT():\n        # Yield the content of the CSV file\n        DFFS=output.dataframes.get()\n        yield DFFS['Chinese trick'].to_csv(index=True)\n\n    @output\n    @render.download(filename=lambda: \"binary_pooling.csv\")\n    async def download_table_binary():\n        # Yield the content of the CSV file\n        DFFS=output.dataframes.get()\n        try:\n            yield DFFS['Binary'].to_csv(index=True)\n        except:\n            yield pd.DataFrame().to_csv(index=True)\n'''\n    @output\n    @render.download(filename=lambda: \"full_pooling.pk\")\n    async def download_pickle():\n        with open('temp.pkl', 'wb') as f:\n            pickle.dump(output.full_pickle, f)\n            f.seek(0)  # Move back to start of file before yielding content\n        \n        # Read back and yield content for download\n        with open('temp.pkl', 'rb') as f:\n            yield f.read()\n\n\n    #@output.plot(\"plot_placeholder\")\n    #def plot():\n        # Placeholder for future plot implementation\n    #    pass\n'''\n\n# Create the app object\napp = App(app_ui, server)", "type": "text"}]